{ @abstract(defines all items that can appear within a Pascal unit's interface)
  @created(11 Mar 1999)
  @cvs($Date$)
  @author(Johannes Berg <johannes@sipsolutions.de>)
  @author(Ralf Junker (delphi@zeitungsjunge.de))
  @author(Marco Schmidt (marcoschmidt@geocities.com))
  @author(Michalis Kamburelis)
  @author(Richard B. Winston <rbwinst@usgs.gov>)

  For each item (type, variable, class etc.) that may appear in a Pascal
  source code file and can thus be taken into the documentation, this unit
  provides an object type which will store name, unit, description and more
  on this item. }

unit PasDoc_Items;

interface

uses
  StringVector,
  ObjectVector,
  Hashes,
  Classes,
  PasDoc_TagManager,
  PasDoc_Serialize,
  PasDoc_SortSettings;

type
  { Accessibility of a field/method.
    
    Do not change the order of these fields without adapting the string
    table below. }
  TAccessibility = (
    { indicates field or method is published }
    STATE_PUBLISHED,
    { indicates field or method is public }
    STATE_PUBLIC,
    { indicates field or method is protected }
    STATE_PROTECTED,
    { indicates field or method is private }
    STATE_PRIVATE,
    { indicates field or method is automated }
    STATE_AUTOMATED
    );

  TAccessibilities = set of TAccessibility;

const
  AccessibilityStr: Array[STATE_PUBLISHED..STATE_AUTOMATED] of string[16] =
  (
   'published',
   'public',
   'protected',
   'private',
   'automated'
  );

type
  TPasCio = class;
  TPasMethod = class;
  TPasProperty = class;
  TPasUnit = class;

  TPasItems = class;
  TPasMethods = class;
  TPasProperties = class;
  
  { Basic linkable item in pasdoc hierarchy }
  TBaseItem = class(TSerializable)
  private
    FRawDescription: string;
    FDetailedDescription: string;
    FFullLink: string;
    FLastMod: string;
    FName: string;
    FAuthors: TStringVector;
    FCreated: string;
    
    procedure SetAuthors(const Value: TStringVector);
    procedure StoreAuthorTag(TagManager: TTagManager; 
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure StoreCreatedTag(TagManager: TTagManager; 
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure StoreLastModTag(TagManager: TTagManager; 
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure StoreCVSTag(TagManager: TTagManager; 
      const TagName, TagDesc: string; var ReplaceStr: string);    
  protected
    { Serialization of TPasItem need to store in stream only data
      that is generated by parser. That's because current approach
      treats "loading from cache" as equivalent to parsing a unit
      and stores to cache right after parsing a unit.
      So what is generated by parser must be written to cache. 
      
      That said,
      
      1. It will not break anything if you will accidentaly store 
      in cache something that is not generated by parser.
      That's because saving to cache will be done anyway right
      after doing parsing, so properties not initialized by parser
      will have their initial values anyway.
      You're just wasting memory for cache, and some cache 
      saving/loading time.
      
      2. For now, in implementation of serialize/deserialize we try 
      to add even things not generated by parser in a commented out 
      code. This way if approach to cache will change some day,
      we will be able to use this code. }
    procedure Serialize(const ADestination: TStream); override;
    procedure Deserialize(const ASource: TStream); override;    
  public
    constructor Create; override;
    destructor Destroy; override;
    
    { It registers handlers that init @link(Authors), 
      @link(Created), @link(LastMod) and remove relevant tags from description. 
      You can override it to add more handlers. }
    procedure RegisterTagHandlers(TagManager: TTagManager); virtual;

    { This searches for item with ItemName *inside* *this* item. 
      This means that e.g. for units it checks whether
      there is some item declared in this unit (like procedure, or class).
      For classes this means that some item is declared within the class
      (like method or property).
      
      All normal rules of ObjectPascal scope apply, which means that
      e.g. if this item is a unit, @name searches for a class named
      ItemName but it *doesn't* search for a method named ItemName
      inside some class of this unit. Just like in ObjectPascal
      the scope of identifiers declared within the class always
      stays within the class. Of course, in ObjectPascal you can
      qualify a method name with a class name, and you can also
      do such qualified links in pasdoc, but this is not handled
      by this routine (see @link(FindName) instead). 
      
      Returns nil if not found.
      
      Note that it never compares ItemName with Self.Name.
      You may want to check this yourself if you want.
      
      Note that for TPasItem descendants, it always returns
      also some TPasItem descendant (so if you use this method
      with some TPasItem instance, you can safely cast result
      of this method to TPasItem).
      
      Implementation in this class always returns nil.
      Override as necessary. }
    function FindItem(const ItemName: string): TBaseItem; virtual;
    
    { This does all it can to resolve link specified by S1, S2, S3.
      n is 0, 1, 2 and specifies how many parts (from S1, S2, S3)
      were actually specified.
      
      While searching this tries to mimic ObjectPascal identifier scope
      as much as it can. It seaches within this item,
      but also within class enclosing this item,
      within unit enclosing this item, then within units used by unit
      of this item. }
    function FindName(S1, S2, S3: string; n: Integer): TBaseItem; virtual;
    
    { Detailed description of this item.
      
      In case of TPasItem, this is something more elaborate
      than @link(TPasItem.AbstractDescription).
      
      This is already in the form suitable for final output,
      ready to be put inside final documentation. }
    property DetailedDescription: string 
      read FDetailedDescription write FDetailedDescription;

    { This stores unexpanded version (as specified
      in user's comment in source code of parsed units)
      of description of this item. 
      
      This is intended to be initialized by parser. }
    property RawDescription: string 
      read FRawDescription write FRawDescription;
    
    { a full link that should be enough to link this item from anywhere else }
    property FullLink: string read FFullLink write FFullLink;
    
    { if assigned, contains string with date of last modification }
    property LastMod: string read FLastMod write FLastMod;
    
    { name of the item }
    property Name: string read FName write FName;

    { Returns the qualified name of the item.
      This is intended to return a concise and not ambigous name.
      E.g. in case of TPasItem it is overriden to return Name qualified
      by class name and unit name. 
      
      In this class this simply returns Name. }
    function QualifiedName: String; virtual;

    { list of strings, each representing one author of this item }
    property Authors: TStringVector read FAuthors write SetAuthors;
    
    { contains '' or string with date of creation }
    property Created: string read FCreated;
  end;
  
  TPasItem = class(TBaseItem)
  private
    FAbstractDescription: string;
    FAbstractDescriptionWasAutomatic: boolean;
    FState: TAccessibility;
    FMyObject: TPasCio;
    FMyUnit: TPasUnit;
    FIsDeprecated: boolean;
    FIsPlatformSpecific: boolean;
    FIsLibrarySpecific: boolean;
    FFullDeclaration: string;

    procedure StoreAbstractTag(TagManager: TTagManager;
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure HandleDeprecatedTag(TagManager: TTagManager;
      const TagName, TagDesc: string; var ReplaceStr: string);
  protected
    procedure Serialize(const ADestination: TStream); override;
    procedure Deserialize(const ASource: TStream); override;
    
    { This does the same thing as @link(FindName) but it *doesn't*
      scan other units. If this item is a unit, it searches only
      inside this unit, else it searches only inside @link(MyUnit)
      unit.
      
      Actually @link(FindName) uses this function. }
    function FindNameWithinUnit(S1, S2, S3: string; n: Integer): TBaseItem; virtual;
  public
    function FindName(S1, S2, S3: string; n: Integer): TBaseItem; override;
    
    procedure RegisterTagHandlers(TagManager: TTagManager); override;
    
    { Abstract description of this item.
      This is intended to be short (e.g. one sentence) description of 
      this object. 
      
      This will be inited from @@abstract tag in RawDescription, 
      or cutted out from first sentence in RawDescription 
      if --auto-abstract was used.
    
      Note that this is already in the form suitable for final output,
      with tags expanded, chars converted etc. }
    property AbstractDescription: string 
      read FAbstractDescription write FAbstractDescription;
      
    (*
      TDocGenerator.ExpandDescriptions sets this property to
      true if AutoAbstract was used and AbstractDescription of this
      item was automatically deduced from the 1st sentence of
      RawDescription.
      
      Otherwise (if @@abstract was specified explicitly, or there
      was no @@abstract and AutoAbstract was false) this is set to false. 
      
      This is a useful hint for generators: it tells them that when they
      are printing *both* AbstractDescription and DetailedDescription of the item
      in one place (e.g. TTexDocGenerator.WriteItemDetailedDescription
      and TGenericHTMLDocGenerator.WriteItemDetailedDescription both do this)
      then they should *not* put any additional space between
      AbstractDescription and DetailedDescription.
      
      This way when user will specify description like
      
      @longcode(#
        { First sentence. Second sentence. }
        procedure Foo;
      #)
      
      and --auto-abstract was on, then "First sentence." is the
      AbstractDescription, " Second sentence." is DetailedDescription,
      AbstractDescriptionWasAutomatic is true and
      and TGenericHTMLDocGenerator.WriteItemDetailedDescription
      can print them as "First sentence. Second sentence."
      
      Without this property, TGenericHTMLDocGenerator.WriteItemDetailedDescription
      would not be able to say that this abstract was deduced automatically
      and would print additional paragraph break that was not present
      in desscription, i.e. "First sentence.<p> Second sentence."
    *)
    property AbstractDescriptionWasAutomatic: boolean
      read FAbstractDescriptionWasAutomatic 
      write FAbstractDescriptionWasAutomatic;
      
    { Returns DetailedDescription if available, otherwise 
      AbstractDescription, otherwise ''. }
    function GetDescription: string;
    
    { Returns true if there is a DetailledDescription or AbstractDescription
      available. In other words, it's equivalent to @code(GetDescription <> ''). }
    function HasDescription: Boolean;  

    function QualifiedName: String; override;    

    { pointer to unit this item belongs to }
    property MyUnit: TPasUnit read FMyUnit write FMyUnit;
    
    { if this item is part of an object or class, the corresponding 
      info object is stored here, nil otherwise }
    property MyObject: TPasCio read FMyObject write FMyObject;
      
    { One of the STATE_xxx constants, determines access rights
      (public, private, etc.). }
    property State: TAccessibility read FState write FState;
    
    { is this item deprecated? }
    property IsDeprecated: boolean read FIsDeprecated write FIsDeprecated;
    
    { Is this item platform specific? 
      This is decided by "platform" hint directive after an item. }
    property IsPlatformSpecific: boolean 
      read FIsPlatformSpecific write FIsPlatformSpecific;
      
    { Is this item specific to a library ? 
      This is decided by "library" hint directive after an item. }
    property IsLibrarySpecific: boolean 
      read FIsLibrarySpecific write FIsLibrarySpecific;   
      

    { This recursively sorts all items inside this item,
      and all items inside these items, etc.
      E.g. in case of TPasUnit, this method sorts all variables, 
      consts, CIOs etc. inside (honouring SortSettings), 
      and also recursively calls Sort(SortSettings) for every CIO.
      
      Note that this does not guarantee that absolutely everything
      inside will be really sorted. Some items may be deliberately
      left unsorted, e.g. Members of TPasEnum are never sorted
      (their declared order always matters,
      so we shouldn't sort them when displaying their documentation
      -- reader of such documentation would be seriously misleaded).
      Sorting of other things depends on SortSettings -- 
      e.g. without ssMethods, CIOs methods will not be sorted.
      
      So actually this method *makes sure that all things that should
      be sorted are really sorted*. }
    procedure Sort(const SortSettings: TSortSettings); virtual;
    
     { Full declaration of the item.
       This is full parsed declaration of the given item.
       
       Note that that this is not used for some descendants.
       Right now it's used only with 
       - TPasConstant 
       - TPasFieldVariable (includes type, default values, etc.) 
       - TPasType
       - TPasMethod (includes parameter list, procedural directives, etc.)
       - TPasProperty (includes read/write and storage specifiers, etc.) 
       - TEnum (for now it's just the same thing as Name)
       - TPasItem when it's a CIO's field. 
       
       The intention is that in the future all TPasItem descendants
       will always have approprtate FullDeclaration set.
       It all requires adjusting appropriate places in PasDoc_Parser to
       generate appropriate FullDeclaration. }
    property FullDeclaration: string read FFullDeclaration write FFullDeclaration;
  end;

  { @abstract(Pascal constant.)
    
    Precise definition of "constant" for pasdoc purposes is 
    "a name associated with a value".
    Optionally, constant type may also be specified in declararion.
    Well, Pascal constant always has some type, but pasdoc is too weak
    to determine the implicit type of a constant, i.e. to unserstand that
    constand @code(const A = 1) is of type Integer. }
  TPasConstant = class(TPasItem)
  end;

  { @abstract(Pascal global variable or field of CIO.)
  
    Precise definition is "a name with some type".
    And optionally with some initial value, for global variables.
    
    In the future we may introduce here some property like Type: TPasType. }
  TPasFieldVariable = class(TPasItem)
  end;
  
  { @abstract(Pascal type (but not a procedural type -- these are expressed
    as @link(TPasMethod).)) }
  TPasType = class(TPasItem)
  end;

  { @abstract(Enumerated type.) }
  TPasEnum = class(TPasType)
  protected
    FMembers: TPasItems;
    procedure Serialize(const ADestination: TStream); override;
    procedure Deserialize(const ASource: TStream); override;
    procedure StoreValueTag(TagManager: TTagManager;
      const TagName, TagDesc: string; var ReplaceStr: string);
  public
    procedure RegisterTagHandlers(TagManager: TTagManager); override;

    destructor Destroy; override;
    constructor Create; override;
    property Members: TPasItems read FMembers;
  end;

  { Methodtype for @link(TPasMethod) }
  TMethodType = (METHOD_CONSTRUCTOR, METHOD_DESTRUCTOR,
    METHOD_FUNCTION, METHOD_PROCEDURE, METHOD_OPERATOR);

  { This represents:
    - global function/procedure,
    - method (function/procedure of a class/interface/object),
    - pointer type to one of the above (in this case Name is the type name). }
  TPasMethod = class(TPasItem)
  protected
    FParams: TStringVector;
    FReturns: string;
    FRaises: TStringVector;
    FWhat: TMethodType;
    procedure Serialize(const ADestination: TStream); override;
    procedure Deserialize(const ASource: TStream); override;
    procedure SetParams(const Value: TStringVector);
    procedure StoreRaisesTag(TagManager: TTagManager; 
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure StoreParamTag(TagManager: TTagManager; 
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure StoreReturnsTag(TagManager: TTagManager; 
      const TagName, TagDesc: string; var ReplaceStr: string);
  public
    constructor Create; override;
    destructor Destroy; override;
    
    { In addition to inherited, this also registers handlers
      that init @link(Params), @link(Returns) and @link(Raises)
      and remove according tags from description. }
    procedure RegisterTagHandlers(TagManager: TTagManager); override;
    
    { }
    property What: TMethodType read FWhat write FWhat;
    
    { Note that Params, Returns, Raises are already in the form processed by
      @link(TTagManager.Execute), i.e. with links resolved,
      html characters escaped etc. So *don't* convert them (e.g. before
      writing to the final docs) once again (by some ExpandDescription or
      ConvertString or anything like that). }
    { }
    property Params: TStringVector read FParams write SetParams;
    property Returns: string read FReturns;
    property Raises: TStringVector read FRaises;
    
    { Are some optional properties (i.e. the ones that may be empty for 
      TPasMethod after parsing unit and expanding tags -- currently this
      means @link(Params), @link(Returns) and @link(Raises)) specified ? }
    function HasMethodOptionalInfo: boolean;
  end;

  TPasProperty = class(TPasItem)
  protected
    FDefault: Boolean;
    FNoDefault: Boolean;
    FIndexDecl: string;
    FStoredID: string;
    FDefaultID: string;
    FWriter: string;
    FPropType: string;
    FReader: string;
    procedure Serialize(const ADestination: TStream); override;
    procedure Deserialize(const ASource: TStream); override;
  public
    { contains the optional index declaration, including brackets }
    property IndexDecl: string read FIndexDecl write FIndexDecl;
    { contains the type of the property }
    property Proptype: string read FPropType write FPropType;
    { read specifier }
    property Reader: string read FReader write FReader;
    { write specifier }
    property Writer: string read FWriter write FWriter;
    { true if the property is the default property }
    property Default: Boolean read FDefault write FDefault;
    { keeps default value specifier }
    property DefaultID: string read FDefaultID write FDefaultID;
    { true if Nodefault property }
    property NoDefault: Boolean read FNoDefault write FNoDefault;
    { keeps Stored specifier }
    property StoredId: string read FStoredID write FStoredID;
  end;

  { enumeration type to determine type of @link(TPasCio) item }
  TCIOType = (CIO_CLASS, CIO_SPINTERFACE, CIO_INTERFACE, CIO_OBJECT, 
    CIO_RECORD, CIO_PACKEDRECORD);

  { @abstract(Extends @link(TPasItem) to store all items in 
    a class / an object, e.g. fields.) }
  TPasCio = class(TPasType)
  protected
    FFields: TPasItems;
    FMethods: TPasMethods;
    FProperties: TPasProperties;
    FAncestors: TStringVector;
    FOutputFileName: string;
    FMyType: TCIOType;
    procedure Serialize(const ADestination: TStream); override;
    procedure Deserialize(const ASource: TStream); override;
  protected
    procedure StoreMemberTag(TagManager: TTagManager;
      const TagName, TagDesc: String; var replaceStr: String);
  public
    constructor Create; override;
    destructor Destroy; override;

    { If this class (or interface or object) contains a field, method or
      property with the name of ItemName, the corresponding item pointer is
      returned. }
    function FindItem(const ItemName: string): TBaseItem; override;

    procedure Sort(const SortSettings: TSortSettings); override;

    procedure RegisterTagHandlers(TagManager: TTagManager); override;
  public
    { name of the ancestor class / object }
    property Ancestors: TStringVector read FAncestors;
    { list of all fields }
    property Fields: TPasItems read FFields;
    { list of all methods }
    property Methods: TPasMethods read FMethods;
    { list of properties }
    property Properties: TPasProperties read FProperties;
    { determines if this is a class, an interface or an object }
    property MyType: TCIOType read FMyType write FMyType;
    { name of documentation output file (if each class / object gets
      its own file, that's the case for HTML, but not for TeX) }
    property OutputFileName: string read FOutputFileName write FOutputFileName;
  end;

  {@name extends @link(TPasItem) to store extra information about a project.
   @name is used to hold an introduction and conclusion to the project.}
  TExternalItem = class(TBaseItem)
  private
    FSourceFilename: string;
    FTitle: string;
    FShortTitle: string;
    FOutputFileName: string;
    procedure SetOutputFileName(const Value: string);
  protected
    procedure HandleTitleTag(TagManager: TTagManager;
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure HandleShortTitleTag(TagManager: TTagManager;
      const TagName, TagDesc: string; var ReplaceStr: string);
    procedure RegisterTagHandlers(TagManager: TTagManager); override;
  public
    { name of documentation output file }
    property OutputFileName: string read FOutputFileName write SetOutputFileName;
    property ShortTitle: string read FShortTitle write FShortTitle;
    property SourceFileName: string read FSourceFilename write FSourceFilename;
    property Title: string read FTitle write FTitle;
  end;

  { extends @link(TPasItem) to store anything about a unit, its constants,
    types etc.; also provides methods for parsing a complete unit.
    
    Note: Remember to always set @link(CacheDateTime) after 
    deserializing this unit. }
  TPasUnit = class(TPasItem)
  protected
    FTypes: TPasItems;
    FVariables: TPasItems;
    FCIOs: TPasItems;
    FConstants: TPasItems;
    FFuncsProcs: TPasMethods;
    FUsesUnits: TStringVector;
    FSourceFilename: string;
    FOutputFileName: string;
    FCacheDateTime: TDateTime;
    FSourceFileDateTime: TDateTime;
    
    procedure Serialize(const ADestination: TStream); override;
    procedure Deserialize(const ASource: TStream); override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure AddCIO(const i: TPasCio);
    procedure AddConstant(const i: TPasItem);
    procedure AddType(const i: TPasItem);
    procedure AddVariable(const i: TPasItem);
    function FindFieldMethodProperty(const S1, S2: string): TPasItem;
    function FindItem(const ItemName: string): TBaseItem; override;

    procedure Sort(const SortSettings: TSortSettings); override;
  public
    { list of classes and objects defined in this unit }
    property CIOs: TPasItems read FCIOs;
    { list of constants defined in this unit }
    property Constants: TPasItems read FConstants;
    { list of functions and procedures defined in this unit }
    property FuncsProcs: TPasMethods read FFuncsProcs;
    
    { The names of all units mentioned in a uses clause in the interface
      section of this unit.
      
      This is never nil.

      After @link(TDocGenerator.BuildLinks), for every i:
      UsesUnits.Objects[i] will point to TPasUnit object with 
      Name = UsesUnits[i] (or nil, if pasdoc's didn't parse such unit). 
      In other words, you will be able to use UsesUnits.Objects[i] to 
      obtain given unit's instance, as parsed by pasdoc. }
    property UsesUnits: TStringVector read FUsesUnits;
    
    { list of types defined in this unit }
    property Types: TPasItems read FTypes;
    { list of variables defined in this unit }
    property Variables: TPasItems read FVariables;
    { name of documentation output file
      THIS SHOULD NOT BE HERE! }
    property OutputFileName: string read FOutputFileName write FOutputFileName;
    
    property SourceFileName: string read FSourceFilename write FSourceFilename;
    property SourceFileDateTime: TDateTime
      read FSourceFileDateTime write FSourceFileDateTime;

    { If WasDeserialized then this specifies the datetime
      of a cache data of this unit, i.e. when cache data was generated.
      If cache was obtained from a file then this is just the cache file
      modification date/time. 
      
      If not WasDeserialized then this property has undefined value -- 
      don't use it. }
    property CacheDateTime: TDateTime 
      read FCacheDateTime write FCacheDateTime;
      
    { Returns if unit WasDeserialized, and file FileName exists, 
      and file FileName is newer than CacheDateTime. 
      
      So if FileName contains some info generated from information
      of this unit, then we can somehow assume that FileName still
      contains valid information and we don't have to write 
      it once again. 
      
      Sure, we're not really 100% sure that FileName still
      contains valid information, but that's how current approach
      to cache works. }
    function FileNewerThanCache(const FileName: string): boolean;
  end;

  { Container class to store a list of @link(TPasItem)s. }
  TPasItems = class(TObjectVector)
  private
    FHash: TObjectHash;
    function GetPasItemAt(const AIndex: Integer): TPasItem;
    procedure SetPasItemAt(const AIndex: Integer; const Value: TPasItem);
    procedure Serialize(const ADestination: TStream);
    procedure Deserialize(const ASource: TStream);
  public
    { Copies all Items from c to this object, not changing c at all. }
    procedure CopyItems(const c: TPasItems);
    { Counts classes, interfaces and objects within this collection. }
    procedure CountCIO(var c, i, o: Integer);
    { Compares each element's name field with Name and returns the item on
      success, nil otherwise.
      Name's case is not regarded. }
    function FindName(const AName: string): TPasItem;
    { Inserts all items of C into this collection.
      Disposes C and sets it to nil. }
    procedure InsertItems(const c: TPasItems);
    { Checks each element's State field and removes all elements with a value
      of STATE_PRIVATE. }
    procedure RemovePrivateItems;

    property PasItemAt[const AIndex: Integer]: TPasItem read GetPasItemAt
      write SetPasItemAt;

    { This sorts all items on this list by their name,
      and also calls @link(TPasItem.Sort Sort(SortSettings))
      for each of these items.
      This way it sorts recursively everything in this list. 
      
      This is equivalent to doing both 
      @link(SortShallow) and @link(SortOnlyInsideItems). }
    procedure SortDeep(const SortSettings: TSortSettings);
    
    { This calls @link(TPasItem.Sort Sort(SortSettings)) 
      for each of items on the list.
      It does *not* sort the items on this list. }
    procedure SortOnlyInsideItems(const SortSettings: TSortSettings);

    { This sorts all items on this list by their name.
      Unlike @link(SortDeep), it does *not* call @link(TPasItem.Sort Sort) 
      for each of these items.
      So "items inside items" (e.g. class methods, if this list contains
      TPasCio objects) remain unsorted. }
    procedure SortShallow;

    { During Add, AObject is associated with AObject.Name using hash table,
      so remember to set AObject.Name *before* calling Add(AObject). }
    procedure Add(const AObject: TPasItem);
    procedure Delete(const AIndex: Integer);
    constructor Create(const AOwnsObject: Boolean); override;
    destructor Destroy; override;
    procedure Clear; override;
    
    { Set IsDeprecated property of all Items to given Value }
    procedure SetIsDeprecated(Value: boolean);
    
    { Set IsPlatformSpecific property of all Items to given Value }
    procedure SetIsPlatformSpecific(Value: boolean);
    
    { Set IsLibrarySpecific property of all Items to given Value }
    procedure SetIsLibrarySpecific(Value: boolean);
    
    { Sets FullDeclaration of every item to 
      1. Name of this item (only if PrefixName) 
      2. + Suffix. 
      Very useful if you have a couple of items that share a common
      declaration in source file, e.g. variables or fields declared like
      @longcode(#
        A, B: Integer;
      #) }
    procedure SetFullDeclaration(PrefixName: boolean; const Suffix: string);
  end;

  { @Name holds a collection of methods. It introduces no
    new methods compared to @link(TPasItems), but this may be
    implemented in a later stage. }
  TPasMethods = class(TPasItems)
  end;

  { @Name holds a collection of properties. It introduces no
    new methods compared to @link(TPasItems), but this may be
    implemented in a later stage. }
  TPasProperties = class(TPasItems)
  end;

  { @abstract(Holds a collection of units.) }
  TPasUnits = class(TPasItems)
  private
    function GetUnitAt(const AIndex: Integer): TPasUnit;
    procedure SetUnitAt(const AIndex: Integer; const Value: TPasUnit);
  public
    property UnitAt[const AIndex: Integer]: TPasUnit
      read GetUnitAt
      write SetUnitAt;
    function ExistsUnit(const AUnit: TPasUnit): Boolean;
  end;

const
  CIORecordType = [CIO_RECORD, CIO_PACKEDRECORD];
  CIONonHierarchy = CIORecordType;

{ Returns lowercased keyword associated with given method type. }
function MethodTypeToString(const MethodType: TMethodType): string;

implementation

uses
  SysUtils, PasDoc_Types, Utils, PasDoc_Tokenizer;

function ComparePasItemsByName(PItem1, PItem2: Pointer): Integer;
begin
  Result := CompareText(TPasItem(PItem1).Name, TPasItem(PItem2).Name);
  // Sort duplicate class names by unit name if available.
  if (Result = 0) and
    (TObject(PItem1).ClassType = TPasCio) and
    (TObject(PItem2).ClassType = TPasCio) then
    if TPasCio(PItem1).MyUnit = nil then begin
      Result := -1
    end else begin
      if TPasCio(PItem2).MyUnit = nil then begin
        Result := 1
      end else begin
        Result := CompareText(TPasCio(PItem1).MyUnit.Name, TPasCio(PItem2).MyUnit.Name);
      end;
    end;
end;

function ComparePasMethods(PItem1, PItem2: Pointer): Integer;
var
  P1: TPasMethod;
  P2: TPasMethod;
begin
  P1 := TPasMethod(PItem1);
  P2 := TPasMethod(PItem2);
  { compare 'method type', order is constructor > destructor > visibility > function, procedure }
  if P1.What = P2.What then begin
    { if 'method type' is equal, compare names }
    if P1.State = P2.State then begin
      Result := CompareText(P1.Name, P2.Name)
    end else begin
      if P1.State < P2.State then begin
        Result := -1
      end else begin
        Result := 1;
      end;
    end;
  end else begin
    if P1.What < P2.What then begin
      Result := -1
    end else begin
      Result := 1;
    end;
  end;
end;

{ TBaseItem ------------------------------------------------------------------- }

constructor TBaseItem.Create;
begin
  inherited Create;
  FAuthors := TStringVector.Create;
end;

destructor TBaseItem.Destroy;
begin
  Authors.Free;
  inherited;
end;

function TBaseItem.FindItem(const ItemName: string): TBaseItem;
begin
  Result := nil;
end;

function TBaseItem.FindName(S1, S2, S3: string; n: Integer): TBaseItem;
begin
  Result := nil;
end;

procedure TBaseItem.StoreAuthorTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if TagDesc = '' then exit;
  if Authors = nil then
    FAuthors := NewStringVector;
  Authors.Add(TagDesc);
  ReplaceStr := '';
end;

procedure TBaseItem.StoreCreatedTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if TagDesc = '' then exit;
  FCreated := TagDesc;
  ReplaceStr := '';
end;

procedure TBaseItem.StoreLastModTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if TagDesc = '' then exit;
  FLastMod := TagDesc;
  ReplaceStr := '';
end;

procedure TBaseItem.StoreCVSTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
var
  s: string;
begin
  if Length(TagDesc)>1 then begin
    case TagDesc[2] of
      'D': begin
             if Copy(TagDesc,1,7) = '$Date: ' then begin
               LastMod := Trim(Copy(TagDesc, 7, Length(TagDesc)-7-1)) + ' UTC';
               ReplaceStr := '';
             end;
           end;
      'A': begin
             if Copy(TagDesc,1,9) = '$Author: ' then begin
               s := Trim(Copy(TagDesc, 9, Length(TagDesc)-9-1));
               if Length(s) > 0 then begin
                 if not Assigned(Authors) then
                   FAuthors := NewStringVector;
                 Authors.AddNotExisting(s);
                 ReplaceStr := '';
               end;
             end;
           end;
      else begin
      end;
    end;
  end;
end;

procedure TBaseItem.RegisterTagHandlers(TagManager: TTagManager);
begin
  inherited;
  TagManager.AddHandler('author', {$IFDEF FPC}@{$ENDIF}StoreAuthorTag,
    [toParameterRequired], []);
  TagManager.AddHandler('created',{$IFDEF FPC}@{$ENDIF} StoreCreatedTag,
    [toParameterRequired, toRecursiveTags], []);
  TagManager.AddHandler('lastmod',{$IFDEF FPC}@{$ENDIF} StoreLastModTag,
    [toParameterRequired, toRecursiveTags], []);
  TagManager.AddHandler('cvs', {$IFDEF FPC}@{$ENDIF}StoreCVSTag,
    [toParameterRequired], []);
end;

procedure TBaseItem.SetAuthors(const Value: TStringVector);
begin
  FAuthors.Assign(Value);
end;

function TBaseItem.QualifiedName: String; 
begin
  Result := Name;
end;

procedure TBaseItem.Deserialize(const ASource: TStream);
begin
  inherited;
  Name := LoadStringFromStream(ASource);
  RawDescription := LoadStringFromStream(ASource);
  
  { No need to serialize, because it's not generated by parser:
  DetailedDescription := LoadStringFromStream(ASource);
  FullLink := LoadStringFromStream(ASource);
  LastMod := LoadStringFromStream(ASource);
  Authors.LoadFromBinaryStream(ASource);
  FCreated := LoadStringFromStream(ASource); }
end;

procedure TBaseItem.Serialize(const ADestination: TStream);
begin
  inherited;
  SaveStringToStream(Name, ADestination);
  SaveStringToStream(RawDescription, ADestination);
  
  { No need to serialize, because it's not generated by parser:
  SaveStringToStream(DetailedDescription, ADestination);
  SaveStringToStream(FullLink, ADestination);
  SaveStringToStream(LastMod, ADestination);
  Authors.SaveToBinaryStream(ADestination);
  SaveStringToStream(Created, ADestination); }
end;

{ TPasItem ------------------------------------------------------------------- }

function TPasItem.FindNameWithinUnit(S1, S2, S3: string; n: Integer): TBaseItem;
var
  p: TBaseItem;
  LS1: string;
begin
  Result := nil;
  LS1 := LowerCase(S1);
  case n of
    0: begin
         Result := FindItem(S1);
         if Result <> nil then Exit;
         
         if Assigned(MyObject) then begin { this item is a method or field }
           p := MyObject.FindItem(S1);
           if Assigned(p) then begin
             Result := p;
             Exit;
           end;
         end;

         if Assigned(MyUnit) then begin
           p := MyUnit.FindItem(S1);
           if Assigned(p) then begin
             Result := p;
             Exit;
           end;
         end;

         if Assigned(MyUnit) and (LS1 = LowerCase(MyUnit.Name)) then begin
           Result := MyUnit;
           Exit;
         end;
       end;

    1: begin
        if Assigned(MyObject) then begin
          if LowerCase(MyObject.Name) = LS1 then begin
            p := MyObject.FindItem(S2);
            if Assigned(p) then begin
              Result := p;
              Exit;
            end;
          end;
        end;

        // RJ: To find links in Unit's objects!
        if Assigned(MyUnit) then begin
          p := MyUnit.FindFieldMethodProperty(S1, S2);
          if Assigned(p) then begin
            Result := p;
            Exit;
          end;
        end;
      end;
  end;
end;

function TPasItem.FindName(S1, S2, S3: string; n: Integer): TBaseItem;

  procedure SearchUsedUnits(UsesUnits: TStringVector);
  var 
    U: TPasUnit;
    i: Integer;
  begin
    for i := 0 to UsesUnits.Count - 1 do
    begin
      U := TPasUnit(UsesUnits.Objects[i]);
      if U <> nil then
      begin
        Result := U.FindNameWithinUnit(S1, S2, S3, n);
        if Result <> nil then Exit;
      end;
    end;
    Result := nil;
  end;

begin
  Result := FindNameWithinUnit(S1, S2, S3, n);

  if Result = nil then
  begin
    { Dirty code: checking for "Self is some class".
      This could be organized better by virtual methods. }
    if Self is TPasUnit then
      SearchUsedUnits(TPasUnit(Self).UsesUnits) else
    if MyUnit <> nil then
      SearchUsedUnits(MyUnit.UsesUnits);
  end;    
end;

function TPasItem.GetDescription: string;
begin
  if DetailedDescription <> '' then begin
    Result := DetailedDescription
  end else begin
    Result := AbstractDescription
  end;
end;

procedure TPasItem.StoreAbstractTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if AbstractDescription <> '' then
    TagManager.DoMessage(1, mtWarning,
      '@abstract tag was already specified for this item. ' +
      'It was specified as "%s"', [AbstractDescription]);
  AbstractDescription := TagDesc;
  ReplaceStr := '';
end;

procedure TPasItem.HandleDeprecatedTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  IsDeprecated := true;
  ReplaceStr := '';
end;

procedure TPasItem.RegisterTagHandlers(TagManager: TTagManager);
begin
  inherited;
  TagManager.AddHandler('abstract', {$IFDEF FPC}@{$ENDIF}StoreAbstractTag,
    [toParameterRequired, toRecursiveTags, toTopLevel], [aiOther]);
  TagManager.AddHandler('deprecated', {$ifdef FPC}@{$endif} HandleDeprecatedTag,
    [], []);
end;

function TPasItem.HasDescription: Boolean;
begin
  HasDescription := (AbstractDescription <> '') or (DetailedDescription <> '');
end;

procedure TPasItem.Sort(const SortSettings: TSortSettings);
begin
  { Nothing to sort in TPasItem }
end;

function TPasItem.QualifiedName: String;
begin
  Result := '';
  if MyUnit <> nil then begin
    Result := Result + MyUnit.Name + '.';
  end;
  if MyObject <> nil then begin
    Result := Result + MyObject.Name + '.';
  end;
  Result := Result + Name;
end;

procedure TPasItem.Deserialize(const ASource: TStream);
begin
  inherited;
  ASource.Read(FState, SizeOf(State));
  ASource.Read(FIsDeprecated, SizeOf(FIsDeprecated));
  ASource.Read(FIsPlatformSpecific, SizeOf(FIsPlatformSpecific));
  ASource.Read(FIsLibrarySpecific, SizeOf(FIsLibrarySpecific));
  FullDeclaration := LoadStringFromStream(ASource);
  
  { No need to serialize, because it's not generated by parser:
  AbstractDescription := LoadStringFromStream(ASource);
  ASource.Read(FAbstractDescriptionWasAutomatic, 
    SizeOf(FAbstractDescriptionWasAutomatic)); }
end;

procedure TPasItem.Serialize(const ADestination: TStream);
begin
  inherited;
  ADestination.Write(FState, SizeOf(State));
  ADestination.Write(FIsDeprecated, SizeOf(FIsDeprecated));
  ADestination.Write(FIsPlatformSpecific, SizeOf(FIsPlatformSpecific));
  ADestination.Write(FIsLibrarySpecific, SizeOf(FIsLibrarySpecific));
  SaveStringToStream(FullDeclaration, ADestination);
  
  { No need to serialize, because it's not generated by parser:
  SaveStringToStream(AbstractDescription, ADestination);
  ADestination.Write(FAbstractDescriptionWasAutomatic, 
    SizeOf(FAbstractDescriptionWasAutomatic)); }
end;

{ TPasEnum ------------------------------------------------------------------- }

constructor TPasEnum.Create;
begin
  inherited Create;
  FMembers := TPasItems.Create(True);
end;

procedure TPasEnum.Deserialize(const ASource: TStream);
begin
  inherited;
  Members.Deserialize(ASource);
end;

destructor TPasEnum.Destroy;
begin
  FMembers.Free;
  inherited;
end;

procedure TPasEnum.RegisterTagHandlers(TagManager: TTagManager);
begin
  inherited RegisterTagHandlers(TagManager);
  
  { Note that @value tag does not have toRecursiveTags,
    and it shouldn't: parameters of this tag will be copied
    verbatim to appropriate member's RawDescription,
    and they will be expanded when this member will be expanded
    by TDocGenerator.ExpandDescriptions.
    This way they will be expanded exactly once, as they should be. }
  TagManager.AddHandler('value', {$IFDEF FPC}@{$ENDIF}StoreValueTag,
    [toParameterRequired], []);
end;

procedure TPasEnum.Serialize(const ADestination: TStream);
begin
  inherited;
  Members.Serialize(ADestination);
end;

procedure TPasEnum.StoreValueTag(TagManager: TTagManager; const TagName,
  TagDesc: string; var ReplaceStr: string);
var
  ValueName: String;
  ValueDesc: String;
  Value: TPasItem;
begin
  ReplaceStr := '';
  ValueDesc := TagDesc;
  ValueName := ExtractFirstWord(ValueDesc);

  Value := Members.FindName(ValueName);
  if Assigned(Value) then
  begin
    if Value.RawDescription = '' then
      Value.RawDescription := ValueDesc else
      TagManager.DoMessage(1, mtWarning,
        '@value tag specifies description for a value "%s" that already' +
        ' has one description.', [ValueName]);
  end else
    TagManager.DoMessage(1, mtWarning,
      '@value tag specifies unknown value "%s"', [ValueName]);
end;

{ TPasItems ------------------------------------------------------------------ }

procedure TPasItems.CopyItems(const c: TPasItems);
var
  i: Integer;
begin
  if ObjectVectorIsNilOrEmpty(c) then Exit;
  for i := 0 to c.Count - 1 do
    Add(TPasItem(c.GetPasItemAt(i)));
end;

procedure TPasItems.CountCIO(var c, i, o: Integer);
var
  j: Integer;
begin
  c := 0;
  i := 0;
  o := 0;

  for j := 0 to Count - 1 do
    case TPasCio(GetPasItemAt(j)).MyType of
      CIO_CLASS:
        Inc(c);
      CIO_INTERFACE:
        Inc(i);
      CIO_OBJECT:
        Inc(o);
    end;
end;

constructor TPasItems.Create(const AOwnsObject: Boolean);
begin
  inherited;
  FHash := TObjectHash.Create;
end;

procedure TPasItems.Delete(const AIndex: Integer);
var
  LObj: TPasItem;
begin
  LObj := GetPasItemAt(AIndex);
  FHash.Delete(LowerCase(LObj.Name));
  inherited Delete(AIndex);
end;

destructor TPasItems.Destroy;
begin
  FHash.Free;
  FHash := nil;
  inherited;
end;

function TPasItems.FindName(const AName: string): TPasItem;
begin
  Result := nil;
  if Length(AName) > 0 then begin
    result := TPasItem(FHash.Items[LowerCase(AName)]);
  end;
end;

function TPasItems.GetPasItemAt(const AIndex: Integer): TPasItem;
begin
  Result := TPasItem(Items[AIndex]);
end;

procedure TPasItems.InsertItems(const c: TPasItems);
var
  i: Integer;
begin
  if ObjectVectorIsNilOrEmpty(c) then Exit;
  for i := 0 to c.Count - 1 do
    Add(TPasItem(c.Items[i]));
end;

procedure TPasItems.Add(const AObject: TPasItem);
begin
  inherited Add(AObject);
  FHash.Items[LowerCase(AObject.Name)] := AObject;
end;

procedure TPasItems.RemovePrivateItems;
var
  i: Integer;
  Item: TPasItem;
begin
  i := 0;
  while (i < Count) do begin
    Item := PasItemAt[i];
    if Assigned(Item) and (Item.State = STATE_PRIVATE) then
      Delete(i)
    else
      Inc(i);
  end;
end;

procedure TPasItems.SetPasItemAt(const AIndex: Integer; const Value:
  TPasItem);
begin
  Items[AIndex] := Value;
end;

procedure TPasItems.SortShallow;
begin
  Sort(@ComparePasItemsByName);
end;

procedure TPasItems.SortOnlyInsideItems(const SortSettings: TSortSettings);
var i: Integer;
begin
  for i := 0 to Count - 1 do 
    PasItemAt[i].Sort(SortSettings);
end;

procedure TPasItems.SortDeep(const SortSettings: TSortSettings);
begin
  SortShallow;
  SortOnlyInsideItems(SortSettings);
end;

procedure TPasItems.Clear;
begin
  if Assigned(FHash) then begin
    // not assigned if destroying
    FHash.Free;
    FHash := TObjectHash.Create;
  end;
  inherited;
end;

procedure TPasItems.Deserialize(const ASource: TStream);
var
  LCount, i: Integer;
begin
  Clear;
  ASource.Read(LCount, SizeOf(LCount));
  for i := 0 to LCount - 1 do
    Add(TPasItem(TPasItem.DeserializeObject(ASource)));
end;

procedure TPasItems.Serialize(const ADestination: TStream);
var
  LCount, i: Integer;
begin
  LCount := Count;
  ADestination.Write(LCount, SizeOf(LCount));
  { Remember to always serialize and deserialize items in the
    same order -- this is e.g. checked by ../../tests/scripts/check_cache.sh }
  for i := 0 to Count - 1 do
    TSerializable.SerializeObject(PasItemAt[i], ADestination);
end;

procedure TPasItems.SetIsDeprecated(Value: boolean);
var i: Integer;
begin
  for i := 0 to Count - 1 do 
    PasItemAt[i].IsDeprecated := Value;
end;

procedure TPasItems.SetIsPlatformSpecific(Value: boolean);
var i: Integer;
begin
  for i := 0 to Count - 1 do 
    PasItemAt[i].IsPlatformSpecific := Value;
end;

procedure TPasItems.SetIsLibrarySpecific(Value: boolean);
var i: Integer;
begin
  for i := 0 to Count - 1 do 
    PasItemAt[i].IsLibrarySpecific := Value;
end;

procedure TPasItems.SetFullDeclaration(PrefixName: boolean; const Suffix: string);
var i: Integer;
begin
  if PrefixName then
  begin
    for i := 0 to Count - 1 do 
      PasItemAt[i].FullDeclaration := PasItemAt[i].Name + Suffix;
  end else
  begin
    for i := 0 to Count - 1 do 
      PasItemAt[i].FullDeclaration := Suffix;
  end;
end;

{ TPasCio -------------------------------------------------------------------- }

constructor TPasCio.Create;
begin
  inherited;
  FFields := TPasItems.Create(True);
  FMethods := TPasMethods.Create(True);
  FProperties := TPasProperties.Create(True);
  FAncestors := TStringVector.Create;
end;

destructor TPasCio.Destroy;
begin
  Ancestors.Free;
  Fields.Free;
  Methods.Free;
  Properties.Free;
  inherited;
end;

procedure TPasCio.Deserialize(const ASource: TStream);
begin
  inherited;
  FFields.Deserialize(ASource);
  FMethods.Deserialize(ASource);
  FProperties.Deserialize(ASource);
  Ancestors.LoadFromBinaryStream(ASource);
  ASource.Read(FMyType, SizeOf(FMyType));

  { No need to serialize, because it's not generated by parser:
  FOutputFileName := LoadStringFromStream(ASource); }
end;

procedure TPasCio.Serialize(const ADestination: TStream);
begin
  inherited;
  FFields.Serialize(ADestination);
  FMethods.Serialize(ADestination);
  FProperties.Serialize(ADestination);
  Ancestors.SaveToBinaryStream(ADestination);
  ADestination.Write(FMyType, SizeOf(FMyType));
  
  { No need to serialize, because it's not generated by parser:
  SaveStringToStream(FOutputFileName, ADestination); }
end;

function TPasCio.FindItem(const ItemName: string): TBaseItem;
begin
  if Fields <> nil then begin
    Result := Fields.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  if Methods <> nil then begin
    Result := Methods.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  if Properties <> nil then begin
    Result := Properties.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  Result := inherited FindItem(ItemName);
end;

procedure TPasCio.Sort(const SortSettings: TSortSettings);
begin
  inherited;
  
  if Fields <> nil then
  begin
    if MyType in CIORecordType then
    begin
      if ssRecordFields in SortSettings then
        Fields.SortShallow;
    end else
    begin
      if ssNonRecordFields in SortSettings then
        Fields.SortShallow;
    end;
  end;

  if (Methods <> nil) and (ssMethods in SortSettings) then
    Methods.Sort(@ComparePasMethods);
  
  if (Properties <> nil) and (ssProperties in SortSettings) then
    Properties.SortShallow;
end;

procedure TPasCio.RegisterTagHandlers(TagManager: TTagManager);
begin
  inherited RegisterTagHandlers(TagManager);
  
  { Note that @member tag does not have toRecursiveTags,
    and it shouldn't: parameters of this tag will be copied
    verbatim to appropriate member's RawDescription,
    and they will be expanded when this member will be expanded
    by TDocGenerator.ExpandDescriptions.
    
    This way they will be expanded exactly once, as they should be. 
    
    Moreover, this allows you to correctly use tags like @param
    and @raises inside @member for a method. }
  TagManager.AddHandler('member', {$IFDEF FPC}@{$ENDIF}StoreMemberTag,
    [toParameterRequired], []);
end;

procedure TPasCio.StoreMemberTag(TagManager: TTagManager; const TagName,
  TagDesc: String; var replaceStr: String);
var
  MemberName: String;
  MemberDesc: String;
  Member: TBaseItem;
begin
  ReplaceStr := '';
  MemberDesc := TagDesc;
  MemberName := ExtractFirstWord(MemberDesc);

  Member := FindItem(MemberName);
  if Assigned(Member) then
  begin
    { Only replace the description if one wasn't specified for it
      already }
    if Member.RawDescription = '' then
      Member.RawDescription := MemberDesc else
      TagManager.DoMessage(1, mtWarning,
        '@member tag specifies description for member "%s" that already' +
        ' has one description.', [MemberName]);
  end else
    TagManager.DoMessage(1, mtWarning,
      '@member tag specifies unknown member "%s".', [MemberName]);
end;

{ TPasUnit ------------------------------------------------------------------- }

constructor TPasUnit.Create;
begin
  inherited Create;
  FTypes := TPasItems.Create(True);
  FVariables := TPasItems.Create(True);
  FCIOs := TPasItems.Create(True);
  FConstants := TPasItems.Create(True);
  FFuncsProcs := TPasMethods.Create(True);
  FUsesUnits := TStringVector.Create;
end;

destructor TPasUnit.Destroy;
begin
  FCIOs.Free;
  FConstants.Free;
  FFuncsProcs.Free;
  FTypes.Free;
  FUsesUnits.Free;
  FVariables.Free;
  inherited;
end;

procedure TPasUnit.AddCIO(const i: TPasCio);
begin
  CIOs.Add(i);
end;

procedure TPasUnit.AddConstant(const i: TPasItem);
begin
  Constants.Add(i);
end;

procedure TPasUnit.AddType(const i: TPasItem);
begin
  Types.Add(i);
end;

procedure TPasUnit.AddVariable(const i: TPasItem);
begin
  Variables.Add(i);
end;

function TPasUnit.FindFieldMethodProperty(const S1, S2: string): TPasItem;
var
  po: TPasCio;
begin
  Result := nil;
  if CIOs = nil then Exit;

  po := TPasCio(CIOs.FindName(S1));
  if Assigned(po) then
    Result := TPasItem(po.FindItem(S2));
end;

function TPasUnit.FindItem(const ItemName: string): TBaseItem;
begin
  if Constants <> nil then begin
    Result := Constants.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  if Types <> nil then begin
    Result := Types.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  if Variables <> nil then begin
    Result := Variables.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  if FuncsProcs <> nil then begin
    Result := FuncsProcs.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  if CIOs <> nil then begin
    Result := CIOs.FindName(ItemName);
    if Result <> nil then Exit;
  end;

  Result := inherited FindItem(ItemName);
end;

function TPasUnit.FileNewerThanCache(const FileName: string): boolean;
begin
  Result := WasDeserialized and FileExists(FileName) and
    (CacheDateTime < FileDateToDateTime(FileAge(FileName)));
end;

procedure TPasUnit.Sort(const SortSettings: TSortSettings);
begin
  inherited;
  
  if CIOs <> nil then
  begin
    if ssCIOs in SortSettings then
      CIOs.SortShallow;
    CIOs.SortOnlyInsideItems(SortSettings);
  end;
      
  if (Constants <> nil) and (ssConstants in SortSettings) then 
    Constants.SortShallow;

  if (FuncsProcs <> nil) and (ssFuncsProcs in SortSettings) then 
    FuncsProcs.SortShallow;
    
  if (Types <> nil) and (ssTypes in SortSettings) then 
    Types.SortShallow;

  if (Variables <> nil) and (ssVariables in SortSettings) then 
    Variables.SortShallow;
    
  if (UsesUnits <> nil) and (ssUsesClauses in SortSettings) then 
    UsesUnits.Sort;
end;

procedure TPasUnit.Deserialize(const ASource: TStream);
begin
  inherited;
  FTypes.Deserialize(ASource);
  FVariables.Deserialize(ASource);
  FCIOs.Deserialize(ASource);
  FConstants.Deserialize(ASource);
  FFuncsProcs.Deserialize(ASource);
  FUsesUnits.LoadFromBinaryStream(ASource);

  { No need to serialize, because it's not generated by parser:
  FOutputFileName := LoadStringFromStream(ASource); 
  FSourceFilename := LoadStringFromStream(ASource);
  SourceFileDateTime := LoadDoubleFromStream(ASource);}
end;

procedure TPasUnit.Serialize(const ADestination: TStream);
begin
  inherited;
  FTypes.Serialize(ADestination);
  FVariables.Serialize(ADestination);
  FCIOs.Serialize(ADestination);
  FConstants.Serialize(ADestination);
  FFuncsProcs.Serialize(ADestination);
  FUsesUnits.SaveToBinaryStream(ADestination);

  { No need to serialize, because it's not generated by parser:
  SaveStringToStream(FOutputFileName, ADestination); 
  SaveStringToStream(FSourceFilename, ADestination);
  SaveDoubleToStream(SourceFileDateTime, ADestination); }
end;

{ TPasUnits ------------------------------------------------------------------ }

function TPasUnits.ExistsUnit(const AUnit: TPasUnit): Boolean;
begin
  Result := FindName(AUnit.Name) <> nil;
end;

function TPasUnits.GetUnitAt(const AIndex: Integer): TPasUnit;
begin
  Result := TPasUnit(Items[AIndex]);
end;

procedure TPasUnits.SetUnitAt(const AIndex: Integer; const Value: TPasUnit);
begin
  Items[AIndex] := Value;
end;

{ TPasMethod ----------------------------------------------------------------- }

destructor TPasMethod.Destroy;
begin
  FParams.Free;
  FRaises.Free;
  inherited Destroy;
end;

procedure TPasMethod.StoreRaisesTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if TagDesc = '' then exit;
  FRaises.Add(TagDesc);
  ReplaceStr := '';
end;

procedure TPasMethod.StoreParamTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if TagDesc = '' then exit;
  FParams.Add(TagDesc);
  ReplaceStr := '';
end;

procedure TPasMethod.StoreReturnsTag(TagManager: TTagManager; 
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if TagDesc = '' then exit;
  FReturns := TagDesc;
  ReplaceStr := '';
end;

function TPasMethod.HasMethodOptionalInfo: boolean;
begin
  Result := 
    (Returns <> '') or
    (not StringVectorIsNilOrEmpty(Params)) or
    (not StringVectorIsNilOrEmpty(Raises));
end;

procedure TPasMethod.Deserialize(const ASource: TStream);
begin
  inherited;
  ASource.Read(FWhat, SizeOf(FWhat));
  
  { No need to serialize, because it's not generated by parser:
  Params.LoadFromBinaryStream(ASource);
  FReturns := LoadStringFromStream(ASource);
  FRaises.LoadFromBinaryStream(ASource); }
end;

procedure TPasMethod.Serialize(const ADestination: TStream);
begin
  inherited;
  ADestination.Write(FWhat, SizeOf(FWhat));
  
  { No need to serialize, because it's not generated by parser:
  Params.SaveToBinaryStream(ADestination);
  SaveStringToStream(FReturns, ADestination);
  FRaises.SaveToBinaryStream(ADestination); }  
end;

constructor TPasMethod.Create;
begin
  inherited;
  FParams := TStringVector.Create;
  FRaises := TStringVector.Create;
end;

procedure TPasMethod.SetParams(const Value: TStringVector);
begin
  FParams.Assign(Value);
end;

procedure TPasMethod.RegisterTagHandlers(TagManager: TTagManager);
begin
  inherited;
  TagManager.AddHandler('raises', {$IFDEF FPC}@{$ENDIF}StoreRaisesTag,
    [toParameterRequired, toRecursiveTags, toTopLevel], [aiOther]);
  TagManager.AddHandler('param', {$IFDEF FPC}@{$ENDIF}StoreParamTag,
    [toParameterRequired, toRecursiveTags, toTopLevel], [aiOther]);
  TagManager.AddHandler('returns',{$IFDEF FPC}@{$ENDIF} StoreReturnsTag,
    [toParameterRequired, toRecursiveTags, toTopLevel], [aiOther]);
  TagManager.AddHandler('return', {$IFDEF FPC}@{$ENDIF}StoreReturnsTag,
    [toParameterRequired, toRecursiveTags, toTopLevel], [aiOther]);
end;

{ TPasProperty --------------------------------------------------------------- }

procedure TPasProperty.Deserialize(const ASource: TStream);
begin
  inherited;
  ASource.Read(FDefault, SizeOf(FDefault));
  ASource.Read(FNoDefault, SizeOf(FNoDefault));
  FIndexDecl := LoadStringFromStream(ASource);
  FStoredID := LoadStringFromStream(ASource);
  FDefaultID := LoadStringFromStream(ASource);
  FWriter := LoadStringFromStream(ASource);
  FPropType := LoadStringFromStream(ASource);
  FReader := LoadStringFromStream(ASource);
end;

procedure TPasProperty.Serialize(const ADestination: TStream);
begin
  inherited;
  ADestination.Write(FDefault, SizeOf(FDefault));
  ADestination.Write(FNoDefault, SizeOf(FNoDefault));
  SaveStringToStream(FIndexDecl, ADestination);
  SaveStringToStream(FStoredID, ADestination);
  SaveStringToStream(FDefaultID, ADestination);
  SaveStringToStream(FWriter, ADestination);
  SaveStringToStream(FPropType, ADestination);
  SaveStringToStream(FReader, ADestination);
end;

{ TExternalItem ---------------------------------------------------------- }

procedure TExternalItem.HandleShortTitleTag(TagManager: TTagManager;
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if ShortTitle <> '' then
    TagManager.DoMessage(1, mtWarning,
      '@shorttitle tag was already specified for this item. ' +
      'It was specified as "%s"', [ShortTitle]);
  ShortTitle := TagDesc;
  ReplaceStr := '';
end;

procedure TExternalItem.HandleTitleTag(TagManager: TTagManager;
  const TagName, TagDesc: string; var ReplaceStr: string);
begin
  if Title <> '' then
    TagManager.DoMessage(1, mtWarning,
      '@title tag was already specified for this item. ' +
      'It was specified as "%s"', [Title]);
  Title := TagDesc;
  ReplaceStr := '';
end;


procedure TExternalItem.RegisterTagHandlers(TagManager: TTagManager);
begin
  inherited;
  TagManager.AddHandler('title', {$IFDEF FPC}@{$ENDIF}HandleTitleTag,
    [toParameterRequired, toRecursiveTags, toTopLevel], [aiOther]);
  TagManager.AddHandler('shorttitle', {$IFDEF FPC}@{$ENDIF}HandleShortTitleTag,
    [toParameterRequired, toTopLevel], [aiOther]);

end;

procedure TExternalItem.SetOutputFileName(const Value: string);
begin
  FOutputFileName := Value;
end;

{ global things ------------------------------------------------------------ }

function MethodTypeToString(const MethodType: TMethodType): string;
const
  { Map TMethodType to TKeyWord }
  MethodTypeToKeyWord: array[TMethodType] of TKeyWord =
  ( KEY_CONSTRUCTOR, KEY_DESTRUCTOR,
    KEY_FUNCTION, KEY_PROCEDURE, KEY_OPERATOR );
begin
  Result := LowerCase(KeyWordArray[MethodTypeToKeyWord[MethodType]]);
end;

initialization
  TSerializable.Register(TPasItem);
  TSerializable.Register(TPasConstant);
  TSerializable.Register(TPasFieldVariable);
  TSerializable.Register(TPasType);
  TSerializable.Register(TPasEnum);
  TSerializable.Register(TPasMethod);
  TSerializable.Register(TPasProperty);
  TSerializable.Register(TPasCio);
  TSerializable.Register(TPasUnit);
end.
